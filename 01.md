<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# Spring Professional Certification Practice Test

Welcome to the Spring Professional Certification practice test. This test contains 20 complex questions covering Spring framework fundamentals, Java configuration, and dependency management. Each question has multiple choice options, and the correct answer with a detailed explanation is provided in a collapsible section.

## Question 1

Which of the following statements about Spring's history is correct?

1. Spring was created as a response to the complexity of EJB 3.0
2. Spring was initially developed by Rod Johnson and described in his book "Expert One-on-One J2EE Design and Development"
3. Spring 1.0 was released in 2006 after the introduction of Java annotations
4. Spring was originally a subproject of the Apache Foundation

<details>
<summary>Réponse</summary>

The correct answer is: 2

Spring was initially developed by Rod Johnson and described in his book "Expert One-on-One J2EE Design and Development" published in 2002. In this book, Johnson criticized the complexity of J2EE (particularly EJB 2.x, not 3.0) and proposed a simpler approach to enterprise Java development. The framework was first released as open source in 2003, and Spring 1.0 was officially released in March 2004, well before 2006. Spring has always been an independent project and was never a subproject of the Apache Foundation. The framework was created to address the complexity of early J2EE specifications and provide a simpler, more testable alternative based on POJOs (Plain Old Java Objects) and dependency injection principles.

Spring eventually became the foundation of Pivotal Software (now part of VMware), not Apache. Its development was driven by the Spring community and later by SpringSource, which was acquired by VMware in 2009.
</details>

## Question 2

Which core principle best describes how Spring manages objects?

1. Object-Oriented Programming
2. Aspect-Oriented Programming
3. Inversion of Control
4. Model-View-Controller

<details>
<summary>Réponse</summary>

The correct answer is: 3

Inversion of Control (IoC) is the core principle that describes how Spring manages objects. IoC represents a fundamental reversal of control where a component's dependencies are provided from the outside rather than the component creating or finding them itself. In Spring, the IoC container is responsible for instantiating, configuring, and assembling objects (beans), as well as managing their lifecycle.

The key aspects of IoC in Spring are:

- Objects do not create or look up their dependencies; they are given their dependencies by the container
- This "inversion" makes code more modular, reusable, and testable
- It reduces coupling between components
- It allows the configuration of components to be externalized from their implementation

While Spring also supports Aspect-Oriented Programming (option 2) through its AOP module and works well with the MVC pattern (option 4), IoC is the foundational principle that defines how the Spring container works. Object-Oriented Programming (option 1) is a general programming paradigm not specific to Spring.

Spring's implementation of IoC is achieved through Dependency Injection, where the container "injects" dependencies into objects rather than the objects creating their dependencies themselves.
</details>

## Question 3

What are the three layers of the core Spring framework architecture?

1. Core, Context, and Beans
2. Core, AOP, and Web
3. Data Access, Web, and AOP
4. Core Container, AOP/Aspects, and Testing

<details>
<summary>Réponse</summary>

The correct answer is: 1

The three layers of the core Spring framework architecture are Core, Context, and Beans.

The Core layer provides the fundamental parts of the framework, including IoC and Dependency Injection features. It includes the `org.springframework.core` package which contains essential utility classes and exception hierarchies.

The Beans layer provides the BeanFactory implementation, which is a sophisticated implementation of the factory pattern. It removes the need for programmatic singletons and allows the separation of configuration and dependency specifications from the actual program logic.

The Context layer builds on the Core and Beans layers and provides a framework-style way to access objects in a manner similar to a JNDI registry. The Context module inherits its features from the Beans module and adds support for internationalization, event propagation, resource loading, and the transparent creation of contexts.

Together, these three layers form what is often referred to as the "Spring Core Container" which is the foundation of the Spring Framework. While options 2, 3, and 4 contain some valid Spring modules, they do not correctly identify the three core architectural layers of the Spring framework. Option 4 is close but combines different levels of the architecture (Core Container is already a combination of layers, while AOP and Testing are separate modules).

This three-layer architecture provides a clear separation of concerns and enables the modular nature of Spring applications.
</details>

## Question 4

Which of the following is NOT a feature of Spring Expression Language (SpEL)?

1. Access to bean properties and methods
2. Method invocation and basic string operations
3. Creating and modifying Java classes at runtime
4. Mathematical and logical operators

<details>
<summary>Réponse</summary>

The correct answer is: 3

Creating and modifying Java classes at runtime is NOT a feature of Spring Expression Language (SpEL). SpEL is a powerful expression language that supports querying and manipulating an object graph at runtime, but it does not have capabilities for dynamic class generation or modification.

The actual features of SpEL include:

- Literal expressions
- Boolean and relational operators
- Regular expressions
- Class expressions
- Accessing properties, arrays, lists, and maps
- Method invocation
- Relational operators
- Assignment
- Calling constructors
- Bean references
- Array construction
- Inline lists and maps
- Ternary operator
- Variables
- User-defined functions
- Collection projection and selection
- Template expressions

SpEL is primarily used for runtime evaluation of expressions within Spring configuration, such as in `@Value` annotations, XML configuration, or bean definitions. It provides a way to perform dynamic lookups and transformations but doesn't modify the Java class structure itself. To create or modify Java classes at runtime, you would need to use technologies like ASM, CGLIB, or ByteBuddy, which Spring may use internally for certain features like proxying, but these are not part of SpEL's capabilities.
</details>

## Question 5

Which of the following modules is NOT part of the Spring Core Container?

1. Spring Beans
2. Spring Context
3. Spring Expression Language (SpEL)
4. Spring AOP

<details>
<summary>Réponse</summary>

The correct answer is: 4

Spring AOP is NOT part of the Spring Core Container. The Spring Core Container specifically consists of:

1. Spring Core - Provides the fundamental parts of the framework, including IoC and Dependency Injection features
2. Spring Beans - Provides the BeanFactory, which is a sophisticated implementation of the factory pattern
3. Spring Context - Builds on Core and Beans and adds additional features like internationalization, event propagation, resource loading, and context-aware classes
4. Spring Expression Language (SpEL) - Provides a powerful expression language for querying and manipulating an object graph at runtime

Spring AOP (Aspect-Oriented Programming) is a separate module in the Spring framework that enables aspect-oriented programming implementation. It allows you to define method interceptors and pointcuts to cleanly decouple code that implements functionality that should be separated. While the AOP module is often used together with the Core Container, it is architecturally distinct and provides cross-cutting functionality rather than core container services.

This distinction is important because understanding the modular architecture of Spring helps developers choose which parts of the framework they need for specific applications. The Core Container provides the essential dependency injection functionality, while other modules like AOP, JDBC, ORM, Web, etc., provide additional capabilities that can be used as needed.
</details>

## Question 6

Consider the following Java configuration class:

```java
@Configuration
public class AppConfig {
    @Bean
    public Service serviceA() {
        return new ServiceImpl();
    }
    
    @Bean
    public Service serviceB() {
        return new ServiceImpl();
    }
}
```

How many instances of ServiceImpl will be created in the Spring application context?

1. One instance, shared between serviceA and serviceB
2. Two instances, one for serviceA and one for serviceB
3. Zero instances, because the ServiceImpl class needs to be annotated with @Component
4. Depends on whether ServiceImpl has a scope defined or not

<details>
<summary>Réponse</summary>

The correct answer is: 2

Two instances of ServiceImpl will be created, one for serviceA and one for serviceB. When using the @Bean annotation on methods within a @Configuration class, each method creates a new bean instance by default. In this case, serviceA() and serviceB() are separate bean definition methods that each create their own instance of ServiceImpl.

This behavior differs from what would happen if you called serviceA() from within serviceB(). In that case, the Spring container would intercept the call due to CGLIB proxying of @Configuration classes, and return the existing bean instance rather than creating a new one.

For example, if the code was:

```java
@Configuration
public class AppConfig {
    @Bean
    public Service serviceA() {
        return new ServiceImpl();
    }
    
    @Bean
    public Service serviceB() {
        return serviceA();  // This returns the same instance as serviceA()
    }
}
```

Then only one instance would be created.

But in the original code, each method independently creates a new ServiceImpl object, resulting in two distinct instances in the application context. This has nothing to do with whether ServiceImpl is annotated with @Component (option 3) since we're using explicit bean definitions in Java configuration. The default scope for beans is "singleton" (per Spring context), but that applies to each bean definition separately, not across different bean definitions (option 4).

This behavior is particularly important to understand when working with Java configuration in Spring, as it affects how objects are shared and managed in the application context.
</details>

## Question 7

Which annotation would you use to make Spring scan packages for annotated components automatically?

1. @ComponentScan
2. @Autowired
3. @Configuration
4. @Import

<details>
<summary>Réponse</summary>

The correct answer is: 1

@ComponentScan is the annotation used to make Spring scan packages for annotated components automatically. This annotation tells Spring where to look for annotated components, configurations, and services that should be registered as beans in the Spring application context.

When you use @ComponentScan, Spring will search for:

- Classes annotated with @Component (and its specializations like @Service, @Repository, @Controller, @RestController)
- Classes annotated with @Configuration
- Classes implementing specific interfaces or extending certain base classes (if configured to do so)

The @ComponentScan annotation can be used in several ways:

- Without arguments: Scans the package of the class where the annotation is defined
- With basePackages attribute: Scans the specified packages (e.g., `@ComponentScan(basePackages = "com.example")`)
- With basePackageClasses attribute: Uses the packages of the specified classes as the starting point for scanning (e.g., `@ComponentScan(basePackageClasses = MyMarkerClass.class)`)
- With includeFilters and excludeFilters: Provides fine-grained control over which components to include or exclude

The other options do not provide component scanning functionality:

- @Autowired (option 2) is used for dependency injection
- @Configuration (option 3) marks a class as a source of bean definitions, but doesn't trigger component scanning
- @Import (option 4) allows for importing other configuration classes, but doesn't provide component scanning functionality

@ComponentScan is commonly used together with @Configuration in Java-based Spring configuration:

```java
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    // Configuration details
}
```

This setup is equivalent to the XML configuration `&lt;context:component-scan base-package="com.example"/&gt;`.
</details>

## Question 8

If you use @ComponentScan without specifying any attributes, which package(s) will Spring scan for components?

1. All packages in the classpath
2. The package of the class declaring the @ComponentScan annotation and all its sub-packages
3. Only the exact package of the class declaring the @ComponentScan annotation
4. The base package defined in the Spring application properties file

<details>
<summary>Réponse</summary>

The correct answer is: 2

When you use @ComponentScan without specifying any attributes, Spring will scan the package of the class declaring the @ComponentScan annotation and all its sub-packages. This is the default behavior of @ComponentScan when no explicit configuration is provided.

For example, if you have:

```java
package com.example.myapp;

@Configuration
@ComponentScan
public class AppConfig {
    // Configuration details
}
```

Spring will scan the `com.example.myapp` package and all its sub-packages (like `com.example.myapp.service`, `com.example.myapp.controller`, etc.) for components to register as beans.

This default behavior is designed to be convenient for most applications, where configuration classes are typically placed at the root package level. It allows all application components to be discovered without having to explicitly list all packages.

The other options are incorrect:

- Option 1 is incorrect because Spring does not scan all packages in the classpath by default, as this would be extremely inefficient and could lead to unwanted bean registrations
- Option 3 is incorrect because Spring scans not only the exact package but also all its sub-packages
- Option 4 is incorrect because Spring does not look for a base package in application properties files for component scanning unless explicitly configured to do so

Understanding this default behavior is crucial for organizing Spring applications correctly. It's a common practice to place the application's main class or configuration class at the root of the package structure to ensure all components are discovered automatically.
</details>

## Question 9

What is the difference between @ComponentScan's `includeFilters` and `excludeFilters` attributes?

1. includeFilters adds additional scanning capabilities beyond annotations, excludeFilters removes specific classes from scanning
2. includeFilters controls which annotations are considered for scanning, excludeFilters only works with XML configuration
3. includeFilters specifies which packages to scan, excludeFilters specifies which packages to ignore
4. includeFilters only works with custom stereotypes, excludeFilters works with any Spring component

<details>
<summary>Réponse</summary>

The correct answer is: 1

includeFilters adds additional scanning capabilities beyond annotations, while excludeFilters removes specific classes from scanning.

The @ComponentScan annotation has two attributes, includeFilters and excludeFilters, which provide fine-grained control over the component scanning process:

- includeFilters: Used to specify additional types to be included in the component scan that might not be caught by the default filters. By default, Spring only scans for classes annotated with @Component, @Repository, @Service, @Controller, or other annotations that are themselves annotated with @Component (stereotype annotations). With includeFilters, you can include other classes based on criteria like custom annotations, assignable types, regex patterns, etc.
- excludeFilters: Used to specify types that should be excluded from component scanning, even if they would normally be included by the default filters or includeFilters. This is useful for preventing specific classes from being registered as beans.

Example usage:

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    includeFilters = @ComponentScan.Filter(
        type = FilterType.ASSIGNABLE_TYPE, 
        classes = MyInterfaceType.class
    ),
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX, 
        pattern = "com\\.example\\.util\\..*"
    )
)
public class AppConfig {
    // Configuration details
}
```

In this example, all classes that implement MyInterfaceType will be included in the scan (even if they don't have component annotations), while any class in the util package matching the regex pattern will be excluded (even if they have component annotations).

The other options are incorrect:

- Option 2 is incorrect because both attributes work with annotations and Java configuration
- Option 3 is incorrect because basePackages (not includeFilters) specifies which packages to scan
- Option 4 is incorrect because includeFilters can work with various criteria, not just custom stereotypes

Understanding these filtering mechanisms allows for precise control over which classes are registered as Spring beans during the component scanning process.
</details>

## Question 10

Which of the following filter types is NOT supported by @ComponentScan's filter mechanism?

1. ANNOTATION
2. ASSIGNABLE_TYPE
3. INHERITANCE
4. REGEX

<details>
<summary>Réponse</summary>

The correct answer is: 3

INHERITANCE is NOT a supported filter type by @ComponentScan's filter mechanism. Spring's @ComponentScan annotation supports the following filter types (defined in the FilterType enum):

1. ANNOTATION - Filters components based on annotations present on the class
2. ASSIGNABLE_TYPE - Filters components based on whether they are assignable to specific types (interfaces or classes)
3. ASPECTJ - Filters components using AspectJ type expression patterns
4. REGEX - Filters components using regex patterns applied to the fully qualified class name
5. CUSTOM - Filters components using a custom implementation of the TypeFilter interface

The "INHERITANCE" option does not exist as a predefined FilterType in Spring. If you want to filter based on inheritance relationships, you would typically use the ASSIGNABLE_TYPE filter, which can identify classes that extend a particular class or implement a specific interface.

Example of using the supported filter types:

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    includeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = MyCustomAnnotation.class),
        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = MyService.class),
        @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*Repository"),
        @ComponentScan.Filter(type = FilterType.ASPECTJ, pattern = "com.example..*Service+"),
        @ComponentScan.Filter(type = FilterType.CUSTOM, classes = CustomTypeFilter.class)
    }
)
public class AppConfig {
    // Configuration details
}
```

Understanding the available filter types is important for implementing precise component scanning strategies in Spring applications, especially in complex scenarios where the default component scanning behavior needs to be customized.
</details>

## Question 11

What is the default scope of a bean defined with @Bean in a @Configuration class?

1. prototype
2. singleton
3. request
4. session

<details>
<summary>Réponse</summary>

The correct answer is: 2

The default scope of a bean defined with @Bean in a @Configuration class is singleton. This means that by default, Spring will create exactly one instance of the bean and return that same instance each time it is requested from the application context.

The singleton scope is Spring's default for all beans, not just those defined with @Bean. This behavior aligns with the most common use case where you want a single, shared instance of a bean throughout your application.

If you want to change the scope of a bean, you can use the @Scope annotation:

```java
@Configuration
public class AppConfig {
    @Bean
    @Scope("prototype")
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

Spring supports several scopes:

1. singleton (default) - One instance per Spring IoC container
2. prototype - A new instance is created each time the bean is requested
3. request - One instance per HTTP request (only valid in a web-aware Spring ApplicationContext)
4. session - One instance per HTTP session (only valid in a web-aware Spring ApplicationContext)
5. application - One instance per ServletContext (only valid in a web-aware Spring ApplicationContext)
6. websocket - One instance per WebSocket (only valid in a web-aware Spring ApplicationContext)

Additionally, you can define custom scopes by implementing the Scope interface.

The singleton scope is efficient for most use cases, as it minimizes object creation and ensures consistency. However, for beans that are stateful or not thread-safe, the prototype scope or other scopes might be more appropriate. Understanding the default scope and when to change it is crucial for proper Spring application design and avoiding potential issues with shared state.
</details>

## Question 12

Consider the following Spring configuration:

```java
@Configuration
public class AppConfig {
    @Bean
    public Engine carEngine() {
        return new V8Engine();
    }
    
    @Bean
    public Car car() {
        return new Car(carEngine());
    }
}
```

Which injection type is being used in this configuration?

1. Constructor injection
2. Setter injection
3. Field injection
4. Method injection

<details>
<summary>Réponse</summary>

The correct answer is: 1

Constructor injection is being used in this configuration. In the `car()` method, the `carEngine()` method is called, and the result (a V8Engine instance) is passed as a parameter to the Car constructor. This is evident from the line `return new Car(carEngine());` which shows that the Engine dependency is being provided via the Car's constructor.

Constructor injection is a pattern where dependencies are provided through a class constructor. It's generally considered the best practice for dependency injection in Spring for several reasons:

- It enforces mandatory dependencies (they can't be null unless explicitly designed to accept null)
- It promotes immutability since dependencies can be made final
- It makes the dependencies explicit in the API
- It simplifies unit testing

In @Configuration classes, Spring ensures that when one @Bean method calls another @Bean method, it returns the same instance that would be obtained from the application context (due to CGLIB proxying of @Configuration classes). This ensures that the singleton scope is maintained.

The other injection types are:

- Setter injection: Dependencies are provided via setter methods (option 2)
- Field injection: Dependencies are injected directly into fields, typically using @Autowired on class fields (option 3)
- Method injection: More rarely used, where a method on the dependent bean is called by the container to provide the dependency (option 4)

Constructor injection is widely recommended by the Spring team and the community as the preferred approach for most scenarios, as it ensures that beans are in a valid state after initialization and makes dependencies clear and explicit.
</details>

## Question 13

What is the purpose of the @Lazy annotation when used with @Bean?

1. It prevents the bean from being created until explicitly requested by @Autowired
2. It ensures the bean is initialized after all other beans have been instantiated
3. It marks the bean to be loaded asynchronously in a separate thread
4. It tells Spring to cache the bean to improve performance

<details>
<summary>Réponse</summary>

The correct answer is: 1

The @Lazy annotation, when used with @Bean, prevents the bean from being created until it is explicitly requested through injection or by directly requesting it from the application context. By default, all singleton beans in Spring are eagerly instantiated during application context initialization. The @Lazy annotation changes this behavior, delaying instantiation until the bean is actually needed.

For example:

```java
@Configuration
public class AppConfig {
    @Bean
    @Lazy
    public ExpensiveService expensiveService() {
        System.out.println("Creating expensive service"); // This will only print when the bean is first requested
        return new ExpensiveServiceImpl();
    }
}
```

The @Lazy annotation can be used at different levels:

- On a @Bean method to make a specific bean lazy-initialized
- On a @Component class to make all instances of that component lazy-initialized
- On a @Configuration class to make all beans defined in that configuration lazy-initialized
- At the @Autowired injection point to lazily inject a dependency, even if the dependency itself is not marked as lazy

Key benefits of using @Lazy include:

- Reducing application startup time by not initializing beans that might not be used
- Breaking circular dependency issues in some cases
- Conserving resources for expensive-to-create beans that aren't always needed

The other options are incorrect:

- Option 2 is incorrect because @Lazy doesn't affect initialization order; it affects whether initialization happens at startup
- Option 3 is incorrect because @Lazy doesn't create beans asynchronously; it simply defers creation
- Option 4 is incorrect because @Lazy doesn't relate to caching; Spring already maintains singleton instances

It's important to note that while @Lazy can be useful in certain scenarios, excessive use can mask design problems and shift errors from startup time to runtime, which can make debugging more difficult.
</details>

## Question 14

Which of the following statements about constructor injection in Spring is FALSE?

1. Constructor injection allows for immutable objects since dependencies can be final
2. Spring can determine which constructor to use when multiple constructors are present
3. Constructor injection guarantees all required dependencies are available when the bean is created
4. Constructor injection is less preferred than field injection in modern Spring applications

<details>
<summary>Réponse</summary>

The correct answer is: 4

The statement "Constructor injection is less preferred than field injection in modern Spring applications" is FALSE. In fact, constructor injection is the recommended and preferred approach for dependency injection in modern Spring applications, while field injection is generally discouraged except for certain specific cases.

The Spring team and community recommend constructor injection for several compelling reasons:

1. It enforces mandatory dependencies - Objects cannot be created without providing all required dependencies through the constructor, ensuring the bean is in a valid state from creation
2. It enables immutability - Dependencies can be declared as final fields, preventing them from being changed after initialization
3. It prevents circular dependencies - Spring can detect circular dependencies at startup when using constructor injection
4. It improves testability - It's easier to provide mock dependencies through constructors in unit tests, without requiring a Spring context or reflection
5. It makes dependencies explicit - The constructor signature clearly shows what dependencies a class requires

The other statements are true:

- Statement 1 is true: Constructor injection allows for dependencies to be declared as final fields, enabling immutable objects
- Statement 2 is true: When multiple constructors are present, Spring can determine which one to use based on available beans, @Autowired annotations, or the @Primary annotation
- Statement 3 is true: Constructor injection ensures all required dependencies are available at object creation time

While field injection (using @Autowired on fields) might appear simpler syntactically, it has significant drawbacks:

- It makes dependencies implicit rather than explicit
- It prevents the use of final fields
- It makes unit testing more difficult, often requiring reflection to set fields
- It can mask design problems by making it too easy to add dependencies

This understanding is crucial for implementing Spring applications that follow best practices and maintain good design principles.
</details>

## Question 15

When does Spring resolve constructor parameter dependencies that have the @Autowired annotation?

1. During application context refresh, before bean instantiation
2. At runtime when the bean is first requested
3. During bean instantiation, but before the constructor is invoked
4. During bean post-processing, after constructor invocation

<details>
<summary>Réponse</summary>

The correct answer is: 3

Spring resolves constructor parameter dependencies that have the @Autowired annotation during bean instantiation, but before the constructor is invoked. This is a critical part of Spring's bean creation lifecycle.

When Spring creates a bean that has constructor-based dependency injection, it follows these steps:

1. Identifies the appropriate constructor to use (either the only one, the one marked with @Autowired, or the "greediest" constructor if multiple exist)
2. Resolves all the dependencies required by the constructor from the application context
3. Instantiates the bean by invoking the constructor with the resolved dependencies
4. Performs additional post-construction operations (like setter injection if applicable)

This order is important because Spring needs to have all dependencies resolved before it can invoke the constructor. If any required dependency cannot be resolved, Spring will fail fast with an appropriate exception rather than creating a partially initialized bean.

It's worth noting that since Spring 4.3, the @Autowired annotation is no longer required for constructor injection if the class has only one constructor. Spring will automatically use that constructor and resolve its parameters. However, if a class has multiple constructors, you need to annotate one with @Autowired to indicate which one Spring should use for dependency injection.

The other options are incorrect:

- Option 1 is incorrect because dependency resolution happens for each specific bean during its instantiation, not globally before all instantiation
- Option 2 is incorrect for singleton-scoped beans, as they are instantiated during context initialization (unless marked as @Lazy)
- Option 4 is incorrect because dependencies must be resolved before constructor invocation, not after

Understanding this process is essential for debugging dependency injection issues and properly configuring complex bean relationships in Spring applications.
</details>

## Question 16

Which of the following is NOT a valid way to inject dependencies in Spring?

1. Using @Autowired on a constructor
2. Using @Inject on a field
3. Using @Resource on a setter method
4. Using @DependsOn on a method parameter

<details>
<summary>Réponse</summary>

The correct answer is: 4

Using @DependsOn on a method parameter is NOT a valid way to inject dependencies in Spring. The @DependsOn annotation has a completely different purpose - it's used at the class or method level to ensure that specific beans are initialized before the annotated bean, but it doesn't directly participate in dependency injection.

The valid ways to inject dependencies in Spring include:

1. Constructor Injection:
    - Using @Autowired on a constructor
    - Not using any annotation if there's only one constructor (since Spring 4.3)
    - Using JSR-330's @Inject annotation on a constructor
2. Setter Injection:
    - Using @Autowired on a setter method
    - Using JSR-330's @Inject on a setter method
    - Using JSR-250's @Resource on a setter method
3. Field Injection:
    - Using @Autowired on a field
    - Using JSR-330's @Inject on a field
    - Using JSR-250's @Resource on a field

The @DependsOn annotation is used to express explicit bean initialization order dependencies. For example:

```java
@Configuration
public class AppConfig {
    @Bean
    @DependsOn("dataSource")  // Ensures dataSource bean is initialized first
    public TransactionManager transactionManager() {
        // bean definition
    }
    
    @Bean
    public DataSource dataSource() {
        // bean definition
    }
}
```

This ensures that the dataSource bean is initialized before the transactionManager bean, which might be necessary if the transaction manager depends on the data source being fully initialized, even if there's no direct reference between the beans.

The annotation cannot be used on method parameters to inject dependencies, which makes option 4 incorrect. Method parameter injection in Spring is typically achieved through the arguments of @Bean methods in @Configuration classes, not through specific annotations on those parameters.
</details>

## Question 17

Which annotation would you use to disambiguate dependencies when multiple beans of the same type exist in the container?

1. @Primary
2. @Qualifier
3. @Named
4. @Bean

<details>
<summary>Réponse</summary>

The correct answer is: 2

@Qualifier is the annotation you would use to disambiguate dependencies when multiple beans of the same type exist in the container. When Spring finds multiple beans that could satisfy a dependency, it needs additional information to determine which one to inject. The @Qualifier annotation provides this information by specifying the exact bean name or qualifier value that should be used.

For example, if you have multiple DataSource beans:

```java
@Configuration
public class DatabaseConfig {
    @Bean
    public DataSource productionDataSource() {
        // configure and return production datasource
    }
    
    @Bean
    public DataSource developmentDataSource() {
        // configure and return development datasource
    }
}
```

You can use @Qualifier to specify which one to inject:

```java
@Service
public class UserService {
    private final DataSource dataSource;
    
    @Autowired
    public UserService(@Qualifier("productionDataSource") DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

The @Qualifier annotation can be used with constructor injection, setter injection, or field injection. It works by matching either the bean name or a qualifier value that can be specified in the bean definition.

Alternative approaches to dependency disambiguation include:

- @Primary (option 1): Designates a primary bean among multiple candidates, which will be used if no qualifier is specified. This is useful when you have a default implementation you want to use most of the time.
- @Named (option 3): Part of JSR-330 (javax.inject) standards, can be used similar to @Qualifier but is not as flexible in Spring's context.
- Custom qualifier annotations: You can create custom annotations annotated with @Qualifier to create more semantic qualifiers.

@Bean (option 4) is not used for disambiguation but for declaring beans in @Configuration classes.

Understanding how to resolve dependency conflicts is essential when working with complex Spring applications that have multiple implementations of the same interface or multiple beans of the same type configured for different purposes.
</details>

## Question 18

Which of the following statements about @Qualifier and @Primary is TRUE?

1. @Primary has precedence over @Qualifier when both are present
2. @Qualifier has precedence over @Primary when both are present
3. Both annotations cannot be used in the same Spring application
4. Both annotations can only be used with constructor injection

<details>
<summary>Réponse</summary>

The correct answer is: 2

@Qualifier has precedence over @Primary when both are present. This means that if you explicitly specify a @Qualifier when injecting a dependency, Spring will use the qualified bean even if another bean of the same type is marked as @Primary.

This behavior makes sense from a design perspective because:

- @Primary establishes a default bean to use when multiple candidates exist but no specific selection is made
- @Qualifier represents an explicit selection of a specific bean, which should override any default setting

For example, consider this configuration:

```java
@Configuration
public class ServiceConfig {
    @Bean
    @Primary
    public PaymentService creditCardPaymentService() {
        return new CreditCardPaymentService();
    }
    
    @Bean
    @Qualifier("paypal")
    public PaymentService paypalPaymentService() {
        return new PayPalPaymentService();
    }
}
```

And this usage:

```java
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    // This will inject creditCardPaymentService (the @Primary bean)
    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

@Service
public class RefundService {
    private final PaymentService paymentService;
    
    // This will inject paypalPaymentService (due to @Qualifier)
    // despite creditCardPaymentService being marked as @Primary
    @Autowired
    public RefundService(@Qualifier("paypal") PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
```

The other options are incorrect:

- Option 1 is incorrect because @Qualifier takes precedence over @Primary
- Option 3 is incorrect because both annotations can be used together in the same application, as shown in the example
- Option 4 is incorrect because both annotations can be used with constructor injection, setter injection, and field injection

Understanding this precedence is important for properly managing dependency resolution in Spring applications with multiple implementations of the same interface or type.
</details>

## Question 19

Which types of dependency injection does Spring support out of the box? (Select all that apply)

1. Constructor injection
2. Setter injection
3. Field injection
4. Interface injection

<details>
<summary>Réponse</summary>

The correct answer is: 1, 2, and 3

Spring supports three types of dependency injection out of the box:

1. Constructor injection - Dependencies are provided through a class constructor
2. Setter injection - Dependencies are provided through setter methods
3. Field injection - Dependencies are injected directly into fields

Interface injection (option 4) is NOT supported by Spring out of the box. Interface injection is a type of dependency injection where an interface defines injection methods that must be implemented by classes wanting to receive the dependency. While this pattern exists in some other DI frameworks, Spring does not use this approach natively.

Here's how the supported types are typically implemented in Spring:

Constructor Injection:

```java
@Component
public class MovieService {
    private final MovieRepository repository;
    
    @Autowired // Optional if this is the only constructor
    public MovieService(MovieRepository repository) {
        this.repository = repository;
    }
}
```

Setter Injection:

```java
@Component
public class MovieService {
    private MovieRepository repository;
    
    @Autowired
    public void setMovieRepository(MovieRepository repository) {
        this.repository = repository;
    }
}
```

Field Injection:

```java
@Component
public class MovieService {
    @Autowired
    private MovieRepository repository;
}
```

Each type of injection has its own advantages and use cases:

- Constructor injection is generally recommended as it ensures all required dependencies are available when the object is constructed, supports immutability, and makes dependencies explicit
- Setter injection is useful for optional dependencies and when circular dependencies cannot be avoided
- Field injection is the most concise but makes testing more difficult and dependencies less explicit

The Spring team generally recommends constructor injection for mandatory dependencies and setter injection for optional dependencies. Field injection, while convenient, is generally discouraged in production code due to its limitations with testing and immutability.
</details>

## Question 20

What happens if a bean dependency marked with @Autowired cannot be resolved by Spring?

1. Spring will throw a NoSuchBeanDefinitionException during application context initialization
2. Spring will create a null reference for the dependency and continue
3. Spring will create a proxy that throws an exception when methods are called on it
4. Spring will skip the injection and log a warning

<details>
<summary>Réponse</summary>

The correct answer is: 1

By default, if a bean dependency marked with @Autowired cannot be resolved by Spring, the framework will throw a NoSuchBeanDefinitionException during application context initialization. This is part of Spring's "fail-fast" approach, which helps identify configuration issues early rather than encountering NullPointerExceptions or similar problems at runtime.

The specific exception thrown might vary depending on the exact cause of the resolution failure:

- NoSuchBeanDefinitionException if no bean of the required type exists
- NoUniqueBeanDefinitionException if multiple candidates exist and there's no way to determine which one to use
- BeanCreationException as a wrapper around more specific exceptions

This behavior makes sense for required dependencies, as an application typically cannot function correctly if mandatory components are missing. However, Spring does provide a way to mark dependencies as optional using the `required` attribute of @Autowired:

```java
@Component
public class MovieService {
    @Autowired(required = false)
    private OptionalDependency optionalDependency;
    
    // With the required=false flag, Spring will not throw an exception
    // if OptionalDependency cannot be found, and the field will remain null
}
```

For constructor injection, you cannot use `required=false` since a constructor parameter cannot be null. Instead, you would need to provide overloaded constructors or use optional types like `Optional&lt;T&gt;` for truly optional dependencies.

The other options are incorrect:

- Option 2 is incorrect because Spring doesn't automatically set null values for unresolved required dependencies
- Option 3 is incorrect because Spring doesn't create exception-throwing proxies for unresolved dependencies
- Option 4 is incorrect because Spring doesn't skip the injection with only a warning (unless required=false is specified)

This behavior is crucial to understand because it affects how applications fail and how you should design for optional dependencies in Spring.
</details>

